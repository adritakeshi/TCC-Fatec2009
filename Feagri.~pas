unit Feagri;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, DB, ADODB, FeagriHorarios;

// {$REGION 'Constantes utilizadas pela classe TCatalogo'}

const MinCred : array[1..10] of integer = (1,0,26,0,56,0,103,0,154,0);
const TotElet = 24;

//{$ENDREGION}

type

// {$REGION 'Tipos Definidos pelas Regras de Negócio da Feagri'}

 RMateria = record
             codigo: integer;
             legenda: string;
             nome: string;
             credito: integer;
             sem: integer;
             turma: integer; 
             estado: integer;
             desc: string;
             cp: integer;
             hora: RHorMat;
             alteracao: boolean;
            end;

 SemestreDoAluno = array of record
                             MateriaSemestre: array[1..15] of RMateria;
                             Consolidado: boolean;
                             Trancado: boolean;
                             Travado: boolean;
                             Credito: integer;
                             Alteracao: boolean;
                            end;

 Movimentacao = array of record
                          Mat: RMateria;
                          SemOrigem: integer;
                          SemDestino: integer;
                         end;

 CadeiaDePreRequisitos = array of integer;

//{$ENDREGION}

// {$REGION 'Estrutura da classe TPreReq'}

  TPreReq = class

   constructor Create(aluRA: string; ano: integer);

   private
    ano:integer;
    aluRA:string;
    PreRequisitos: CadeiaDePreRequisitos;
    procedure CarregaPreRequisito;
    function  TemPreRequisito(cod: integer): boolean;
   
    public
     PreReq: array of record
      codigo: integer;
      pre_req: array[1..5] of integer;
     end;
     function  PodeCursar(Feagri :SemestreDoAluno; Dispensa: array of RMateria; mat, sem:integer): boolean;
     function  PodeCursarPreRequisito(Feagri :SemestreDoAluno; mat: integer; sem: Integer):boolean;
     procedure DescobrirCadeia(cod:integer);
     function  ConsultarCadeiaDePreRequisito: CadeiaDePreRequisitos;
  end;

 
// {$ENDREGION}

// {$REGION 'Estrutura da classe TCatalogo'}

  TCatalogo = class

  constructor Create(aluRA: string; aluAno: integer);   

   private
    RA: string;
    ano: integer;
    ListaDeAlteracoes: Movimentacao;

    procedure CarregaSemestre;
    procedure CarregaMateriasDoHistorico;
    procedure CarregaMateriasEletivas;
    procedure CarregaMateriasDispensadas;
    procedure CarregaMateriasJubiladas;
    procedure CarregaHorariosDaMateria;
   	procedure ApagaMateria(var mat: RMateria);
    procedure OrganizaMateriaDaLista(Lista, indice, sem: integer);
    procedure AdicionaSemestre;
    procedure RemoveSemestre;
    procedure MovimentaGrade(sem:integer; var Hora: THorarios; Req: TPreReq);
    procedure OrganizaLista;
    function  VerificaCoeficiente(mat:RMateria;sem:integer):boolean;
    function  VerificaJubilamento(sem:integer; creditos:integer):boolean;
    function  CalculaTotalCredito:integer;
    function  SemestrePar(sem:integer): boolean;
    function  CalculaCreditoCursado(sem:integer):integer;
    function  TemCredito(sem: Integer; cred: integer):boolean;
    function  MudaSemestre(codigo: integer; SemOri, SemDes: Integer; Hora: THorarios; Req: TPreReq): boolean; overload;

   public
    SemestreFeagri: SemestreDoAluno;
    Eletivas: array of RMateria;
    AproveitamentoDeEstudos: array of RMateria;
    SemestreJubilado: array of RMateria;

    procedure AdicionaMateriaNaLista(Lista:integer; mat:  RMateria; sem: integer);
    procedure RemoveMateriaDaLista(Lista:integer; mat: RMateria; sem: integer);
    function  ConsultaLegenda(cod:integer):string;
    procedure DispensaMateria(mat:string);
    procedure TornaSimulada(legenda: string; SemOri,SemDes:integer);
    procedure TornaNormal(legenda: string; SemOri,SemDes:integer);
    procedure TravaSemestre(sem:integer);
    procedure TrancaSemestre(sem:integer; var Hora: THorarios; Req: TPreReq);
    procedure ConsolidaSemestre(sem:integer; var Hora: THorarios; Req: TPreReq);
    function  MudaSemestre(mat: string; SemOri, SemDes: Integer; var Hora: THorarios; Req: TPreReq): boolean; overload;
    function  ListaAlteracoes: Movimentacao;
    procedure SalvaCatalogo;
    procedure ResetCatalogo;
    function  TamSem(sem: array of RMateria; tipo:integer): integer;
    function  PosVetMat(leg:string; sem: array of RMateria; tipo:integer):integer;
  end;

// {$ENDREGION}

 implementation

uses principal;

constructor TCatalogo.Create(aluRA: string; aluAno: Integer);
begin
  self.RA:= aluRa;
  self.ano:= aluAno;
  try
   self.CarregaSemestre;
   self.CarregaMateriasDoHistorico;
   self.CarregaMateriasEletivas;
   self.CarregaMateriasDispensadas;
   self.CarregaMateriasJubiladas;
   self.CarregaHorariosDaMateria;
  except
   Application.MessageBox('Erro ao carregar os dados','Feagri',16);
  end;
end;

// {$REGION 'Métodos Privados de negócio da classe TCatalogo'}

function TCatalogo.PosVetMat(leg:string; sem: array of RMateria; tipo:integer):integer;
var pos: integer;
begin
  pos:= low(sem);
  showmessage(inttostr(pos));
  while sem[pos].legenda <> leg do
    inc(pos);
  if tipo >= 1 then
  Result := pos+1
  else Result := pos;

  //showmessage(inttostr(pos)+'-'+sem[pos].legenda);
end;

function TCatalogo.TamSem(sem: array of RMateria; tipo:integer): integer;
var i:integer;
begin
  if tipo >= 1 then
  begin
      i := 1;
      if sem[i].legenda = '' then
          Result := 0
      else begin
          while (sem[i].legenda <> '') and (i < 15) do
            inc(i);
          Result := i;
      end;
  end else Result := length(sem);
end;

procedure TCatalogo.CarregaSemestre;
var rs: _recordset;
begin
rs:= formprincipal.Feagri_Conector.Execute('select * from semestre where aluRA = '+self.RA);
SetLength(self.SemestreFeagri,rs.RecordCount);

while not rs.EOF do
begin
 with (self.SemestreFeagri[strtoint(rs.Fields[0].Value)-1]) do
 begin
  Consolidado:= StrToBool(rs.Fields[1].Value);
  Trancado:= StrToBool(rs.Fields[2].Value);
  Travado:= StrToBool(rs.Fields[3].Value);
  alteracao:= false;
 end;
 rs.MoveNext;
end;

end;

procedure TCatalogo.CarregaMateriasDoHistorico;
var rs: _recordset;
    sem: integer;
    mat: integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select semcur, cat_mat.cmcod, matcod, matnom,'
+ ' matcred, matsem, matdef, matcp, histcod from cat_mat_tur_hist, cat_mat'
+ ' where cat_mat.cmcod = cat_mat_tur_hist.cmcod and semcur >= '+inttostr(low(self.SemestreFeagri)+1)
+ ' and semcur <= '+inttostr(high(self.SemestreFeagri)+1)+' and aluRA = '+ self.RA + ' order by semcur');

sem:=0;
mat:=1;

while not rs.EOF do
begin
 if (sem <> rs.Fields[0].Value) then
 begin
  sem:= rs.Fields[0].Value;
  mat:=1;
 end;
 with (self.SemestreFeagri[StrToInt(rs.Fields[0].Value)-1].MateriaSemestre[mat]) do
 begin
  codigo:= StrToInt(rs.Fields[1].Value);
  legenda:= rs.Fields[2].Value;
  nome:= rs.Fields[3].Value;
  credito:= StrToInt(rs.Fields[4].Value);
  sem:= StrToInt(rs.Fields[5].Value);
  desc:= rs.Fields[6].Value;
  cp:= StrToInt(rs.Fields[7].Value);
  estado:= StrToInt(rs.Fields[8].Value);
  alteracao:= false;
 end;
 self.SemestreFeagri[StrToInt(rs.Fields[0].Value)-1].Credito:=
  self.SemestreFeagri[StrToInt(rs.Fields[0].Value)-1].Credito + rs.Fields[4].Value;
 Inc(mat);
 rs.MoveNext;
end;

end;

procedure TCatalogo.CarregaMateriasEletivas;
var rs: _recordset;
  I: Integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select cat_mat.cmcod, matcod, matnom,'
+ ' matcred, matsem, matdef, matcp, histcod from cat_mat_tur_hist, cat_mat'
+ ' where cat_mat.cmcod = cat_mat_tur_hist.cmcod and semcur = 0 and aluRA = '
+ self.RA + ' order by matcod');

SetLength(self.Eletivas,rs.RecordCount);

for I := Low(self.Eletivas) to High(self.Eletivas) do
begin
 with (self.Eletivas[I]) do
 begin
  codigo:= StrToInt(rs.Fields[0].Value);
  legenda:= rs.Fields[1].Value;
  nome:= rs.Fields[2].Value;
  credito:= StrToInt(rs.Fields[3].Value);
  sem:= StrToInt(rs.Fields[4].Value);
  desc:= rs.Fields[5].Value;
  cp:= StrToInt(rs.Fields[6].Value);
  estado:= StrToInt(rs.Fields[7].Value);
  alteracao:= false;
 end;
 rs.MoveNext;
end;

end;

procedure TCatalogo.CarregaMateriasDispensadas;
var rs: _recordset;
    I: integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select cat_mat.cmcod, matcod, matnom,'
+ ' matcred, matsem, matdef, matcp, histcod from cat_mat_tur_hist, cat_mat'
+ ' where cat_mat.cmcod = cat_mat_tur_hist.cmcod and histcod = 5 and aluRA = '+self.RA
+ ' order by matcod');

SetLength(self.AproveitamentoDeEstudos,rs.RecordCount);

for I := Low(self.AproveitamentoDeEstudos) to High(self.AproveitamentoDeEstudos) do
begin
 with (self.AproveitamentoDeEstudos[I]) do
 begin
  codigo:= StrToInt(rs.Fields[0].Value);
  legenda:= rs.Fields[1].Value;
  nome:= rs.Fields[2].Value;
  credito:= StrToInt(rs.Fields[3].Value);
  sem:= StrToInt(rs.Fields[4].Value);
  desc:= rs.Fields[5].Value;
  cp:= StrToInt(rs.Fields[6].Value);
  estado:= StrToInt(rs.Fields[7].Value);
  alteracao:= false;
 end;
 rs.MoveNext;
end;

end;

procedure TCatalogo.CarregaMateriasJubiladas;
var rs: _recordset;
    I: integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select cat_mat.cmcod, matcod, matnom,'
+ ' matcred, matsem, matdef, matcp, histcod from cat_mat_tur_hist, cat_mat'
+ ' where cat_mat.cmcod = cat_mat_tur_hist.cmcod and histcod = 6 and aluRA = '+self.RA
+ ' order by matcod');

SetLength(self.SemestreJubilado,rs.RecordCount);

for I := Low(self.SemestreJubilado) to High(self.SemestreJubilado) do
begin
 with (self.SemestreJubilado[I]) do
 begin
  codigo:= StrToInt(rs.Fields[0].Value);
  legenda:= rs.Fields[1].Value;
  nome:= rs.Fields[2].Value;
  credito:= StrToInt(rs.Fields[3].Value);
  sem:= StrToInt(rs.Fields[4].Value);
  desc:= rs.Fields[5].Value;
  cp:= StrToInt(rs.Fields[6].Value);
  estado:= StrToInt(rs.Fields[7].Value);
  alteracao:= false;
 end;
 rs.MoveNext;
end;  

end;

function GetHourOfDay(hora:string):integer;
begin
Result:= 1;
if hora = '07:00' then Result:= 1;
if hora = '08:00' then Result:= 2;
if hora = '09:00' then Result:= 3;
if hora = '10:00' then Result:= 4;
if hora = '11:00' then Result:= 5;
if hora = '12:00' then Result:= 6;
if hora = '13:00' then Result:= 7;
if hora = '14:00' then Result:= 8;
if hora = '15:00' then Result:= 9;
if hora = '16:00' then Result:= 10;
if hora = '17:00' then Result:= 11;
if hora = '18:00' then Result:= 12;
if hora = '19:00' then Result:= 13;
if hora = '20:00' then Result:= 14;
if hora = '21:00' then Result:= 15;
if hora = '22:00' then Result:= 16;
if hora = '23:00' then Result:= 17;
end;

function GetDayOfWeek(dia:string):integer;
begin
Result:= 1;
if dia = 'segunda' then Result:= 2;
if dia = 'terça'   then Result:= 3;
if dia = 'quarta'  then Result:= 4;
if dia = 'quinta'  then Result:= 5;
if dia = 'sexta'   then Result:= 6;
if dia = 'sábado'  then Result:= 7;
end;

procedure TCatalogo.CarregaHorariosDaMateria;
var rs:_recordset;
    I,J:integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select Cat_Mat.CMCod, IniHor, DiaHor, CMTCod from cat_mat_tur_hor, cat_mat '
+ ' where CatCod = '+IntToStr(self.ano) + ' and matsem <> 0');
while not rs.EOF do
begin

 for I := low(SemestreFeagri) to high(SemestreFeagri) do
  for J := 1 to 15 do
   if self.SemestreFeagri[I].MateriaSemestre[J].codigo = rs.Fields[0].Value then
   begin
     self.SemestreFeagri[I].MateriaSemestre[J].turma := strtoint(rs.Fields[3].Value);
     SetLength(self.SemestreFeagri[I].MateriaSemestre[J].hora,high(self.SemestreFeagri[I].MateriaSemestre[J].hora)+2);
     self.SemestreFeagri[I].MateriaSemestre[J].hora[high(self.SemestreFeagri[I].MateriaSemestre[J].hora)].DiaDaSemana:= GetDayOfWeek(rs.fields[2].value);
     self.SemestreFeagri[I].MateriaSemestre[J].hora[high(self.SemestreFeagri[I].MateriaSemestre[J].hora)].Hora:= GetHourOfDay(rs.fields[1].value);
   end;

  for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
   if self.AproveitamentoDeEstudos[I].codigo = rs.Fields[0].Value then
   begin
     self.AproveitamentoDeEstudos[I].turma := strtoint(rs.Fields[3].Value);
     SetLength(self.AproveitamentoDeEstudos[I].hora,high(self.AproveitamentoDeEstudos[I].hora)+2);
     self.AproveitamentoDeEstudos[I].hora[high(self.AproveitamentoDeEstudos[I].hora)].DiaDaSemana:= GetDayOfWeek(rs.fields[2].value);
     self.AproveitamentoDeEstudos[I].hora[high(self.AproveitamentoDeEstudos[I].hora)].Hora:= GetHourOfDay(rs.fields[1].value);
   end;

  for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
   if self.SemestreJubilado[I].codigo = rs.Fields[0].Value then
   begin
     self.SemestreJubilado[I].turma := strtoint(rs.Fields[3].Value);
     SetLength(self.SemestreJubilado[I].hora,high(self.SemestreJubilado[I].hora)+2);
     self.SemestreJubilado[I].hora[high(self.SemestreJubilado[I].hora)].DiaDaSemana:= GetDayOfWeek(rs.fields[2].value);
     self.SemestreJubilado[I].hora[high(self.SemestreJubilado[I].hora)].Hora:= GetHourOfDay(rs.fields[1].value);
   end;

 rs.MoveNext;
end;

end;

procedure TCatalogo.AdicionaMateriaNaLista(Lista: integer; mat: RMateria; sem: Integer);
var I: Integer;
begin
// lista: grupo de semestre destino; mat: materia q será tranferida, sem - semestre destino
case Lista of
 1:
 for I := 1 to 15 do
 begin
  if (self.SemestreFeagri[sem-1].MateriaSemestre[I].legenda = '') then
  begin
   mat.alteracao:= true;
   self.SemestreFeagri[sem - 1].MateriaSemestre[I]:= mat;
   self.SemestreFeagri[sem - 1].Credito:= self.SemestreFeagri[sem - 1].Credito + self.SemestreFeagri[sem - 1].MateriaSemestre[I].Credito;
   exit;
  end;
 end;

 2:
 begin
  SetLength(self.Eletivas,high(self.Eletivas)+2);
  mat.alteracao:= true;
  self.Eletivas[high(self.Eletivas)]:= mat;
  exit;
 end;

 3:
 begin
  SetLength(self.AproveitamentoDeEstudos,high(self.AproveitamentoDeEstudos)+2);
  mat.alteracao:= true;
  mat.estado:= 5;
  self.AproveitamentoDeEstudos[high(self.AproveitamentoDeEstudos)]:= mat;
  exit;
 end;

 4:
 begin
  SetLength(self.SemestreJubilado,high(self.SemestreJubilado)+2);
  mat.alteracao:= true;
  mat.estado:= 6;
  exit;
 end;

end;
end;

procedure TCatalogo.ApagaMateria(var mat: RMateria);
begin
 mat.codigo:= 0;
 mat.legenda:= '';
 mat.nome:= '';
 mat.credito:= 0;
 mat.sem:= 0;
 mat.turma:= 0;
 mat.desc:= '';
 mat.cp:= 0;
end;


procedure TCatalogo.RemoveMateriaDaLista(Lista:integer; mat: RMateria; sem: Integer);
var I,indice: Integer;
begin
indice:=0;
case Lista of
 1:
 begin
  for I := 1 to 15 do
  begin
   if (self.SemestreFeagri[sem-1].MateriaSemestre[I].legenda = mat.legenda) then
   begin
    self.SemestreFeagri[sem -1].Credito:= self.SemestreFeagri[sem - 1].Credito - self.SemestreFeagri[sem - 1].MateriaSemestre[I].Credito;
    self.ApagaMateria(self.SemestreFeagri[sem-1].MateriaSemestre[I]);
    indice:= I;
    break;
   end;
  end;
 end;

 2:
 begin
   for I := low(self.Eletivas) to high(self.Eletivas) do
   begin
     if (self.Eletivas[I].legenda = mat.legenda) then
     begin
       self.ApagaMateria(self.Eletivas[I]);
       indice:= I;
       break;
     end;
   end;
 end;

 3:
 begin
   for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
   begin
     if (self.AproveitamentoDeEstudos[I].legenda = mat.legenda) then
     begin
       self.ApagaMateria(self.AproveitamentoDeEstudos[I]);
       indice:= I;
       break;
     end;
   end;
  end;

 4:
 begin
   for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
   begin
     if (self.SemestreJubilado[I].legenda = mat.legenda) then
     begin
       self.ApagaMateria(self.SemestreJubilado[I]);
       indice:= I;
       break;
     end;
   end;
 end;

end;

self.OrganizaMateriaDaLista(Lista,indice,sem);

end;

procedure TCatalogo.OrganizaMateriaDaLista(Lista: Integer; indice: Integer; sem: Integer);
var I:integer;
begin
case Lista of
 1:
 begin
  for I := indice to 14 do
   self.SemestreFeagri[sem-1].MateriaSemestre[I]:= self.SemestreFeagri[sem-1].MateriaSemestre[I+1];
  self.ApagaMateria(self.SemestreFeagri[sem].MateriaSemestre[15]);
  exit;
 end;

 2:
 begin
  for I := indice to high(self.Eletivas) do
   self.Eletivas[I]:= self.Eletivas[I+1];
  self.ApagaMateria(self.Eletivas[high(self.Eletivas)]);
  SetLength(self.Eletivas,high(self.Eletivas));
  exit;
 end;

 3:
 begin
  for I := indice to high(self.AproveitamentoDeEstudos) do
   self.AproveitamentoDeEstudos[I]:= self.AproveitamentoDeEstudos[I+1];
  self.ApagaMateria(self.AproveitamentoDeEstudos[high(self.AproveitamentoDeEstudos)]);
  SetLength(self.AproveitamentoDeEstudos,high(self.AproveitamentoDeEstudos));
  exit;
 end;

 4:
 begin
  for I := indice to high(self.SemestreJubilado) do
   self.SemestreJubilado[I]:= self.SemestreJubilado[I+1];
  self.ApagaMateria(self.SemestreJubilado[high(self.SemestreJubilado)]);
  SetLength(self.SemestreJubilado,high(self.SemestreJubilado));
  exit;
 end;

end;
end;


procedure TCatalogo.AdicionaSemestre;
begin
  SetLength(self.SemestreFeagri, high(self.SemestreFeagri)+2);
end;

procedure TCatalogo.RemoveSemestre;
begin
  SetLength(self.SemestreFeagri, high(self.SemestreFeagri));
end;

function TCatalogo.SemestrePar(sem: Integer):boolean;
begin
 Result:= (sem mod 2 = 0);
end;

function TCatalogo.VerificaJubilamento(sem: Integer; creditos: Integer): boolean;
begin
 Result:= (self.CalculaCreditoCursado(sem) < MinCred[sem]);
end; 

function TCatalogo.CalculaTotalCredito:integer;
var I,J,Cred:integer;
begin
 Cred:= TotElet;

  for I := low(self.SemestreFeagri) to high(self.SemestreFeagri) do
   for J := 1 to 15 do
    if (self.SemestreFeagri[I].MateriaSemestre[J].legenda <> '') and (SemestreFeagri[I].MateriaSemestre[J].sem in [1..10]) then
     Cred:= Cred + SemestreFeagri[I].MateriaSemestre[J].credito;

  for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
    if AproveitamentoDeEstudos[I].sem in [1..10] then
     Cred:= Cred + self.AproveitamentoDeEstudos[I].credito;

   for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
    if self.SemestreJubilado[I].sem in [1..10] then
     Cred:= Cred + self.SemestreJubilado[I].credito;

 Result:= Cred;
end;

function TCatalogo.VerificaCoeficiente(mat: RMateria; sem: Integer):boolean;
var Cred:integer;
    Porcentagem: real;
begin
 Cred:= self.CalculaCreditoCursado(sem);
 Porcentagem:= (Cred / self.CalculaTotalCredito)*100;
 Result:= (Porcentagem > mat.cp);
end;

function TCatalogo.CalculaCreditoCursado(sem:integer):integer;
var I,TotCred:integer;
begin
 TotCred:= 0;
 for I := 0 to sem - 1 do
  TotCred:= TotCred + self.SemestreFeagri[I].Credito;
 Result:= TotCred;
end;

function TCatalogo.TemCredito(sem: Integer; cred: integer):boolean;
var TotCred:integer;
begin
 TotCred:= 30 + ((sem  - 1)*48);
 TotCred:= TotCred - self.CalculaCreditoCursado(sem);
 Result:= (TotCred >= cred);
end;

function TCatalogo.MudaSemestre(codigo: Integer; SemOri: Integer; SemDes: Integer; Hora: THorarios; Req: TPreReq):boolean;
var erro:boolean;
    I,Lista: integer;
    Disciplina: RMateria;
begin

 erro:= false;
 Lista:= 1;

 for I := 1 to 15 do
 begin
  if self.SemestreFeagri[SemOri-1].MateriaSemestre[I].codigo = codigo then
  begin
   Disciplina:= self.SemestreFeagri[SemOri-1].MateriaSemestre[I];
   break;
  end;
 end;

 if Disciplina.sem <> 0 then
 begin
  if (self.SemestrePar(Disciplina.sem) <> self.SemestrePar(SemDes)) then
    erro:= true
  else
  if (not self.TemCredito(SemDes,Disciplina.credito)) then
   erro:= true
  else
  if (not self.VerificaCoeficiente(Disciplina,SemDes)) then
   erro:= true

 {if (not Hora.VerificaHorarioDisponivel) then
   erro:= true;
 }

  else
   if (self.SemestreFeagri[SemDes - 1].Travado) then
    self.SemestreFeagri[SemDes - 1].Travado:= false;

  end

  else
   Lista:= 2;

   if erro then
    Result:= false
    else
     begin
      self.RemoveMateriaDaLista(Lista,Disciplina,SemOri);
      self.AdicionaMateriaNaLista(Lista,Disciplina,SemDes);
      Result:= true;
     end;

end;

procedure TCatalogo.MovimentaGrade(sem:integer; var Hora: THorarios; Req: TPreReq);
var I,J,K,L,SemOri,SemDestinoAux,SemDestino:integer;
    ReqFeagri: CadeiaDePreRequisitos;
begin

 I:=1;

  while self.SemestreFeagri[sem - 1].MateriaSemestre[I].legenda <> '' do
   begin
    SemDestino:= sem + 2;
     if self.SemestreFeagri[sem - 1].MateriaSemestre[I].estado = 3 then
     begin

        while (self.MudaSemestre(self.SemestreFeagri[sem - 1].MateriaSemestre[I].codigo,sem,SemDestino,Hora,Req) = false) and (SemDestino <= high(self.SemestreFeagri)) do
         SemDestino := SemDestino + 2;

        SetLength(self.ListaDeAlteracoes,high(self.ListaDeAlteracoes)+2);
        self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].Mat:= self.SemestreFeagri[sem - 1].MateriaSemestre[I];
        self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].SemOrigem:= sem + 1;

        if SemDestino > high(self.SemestreFeagri) then
        begin
          self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].SemDestino:= SemDestino + 1;
          self.RemoveMateriaDaLista(1,self.SemestreFeagri[sem - 1].MateriaSemestre[I],sem);
          self.AdicionaMateriaNaLista(4,self.SemestreFeagri[sem - 1].MateriaSemestre[I],0);
        end
        else
          self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].SemDestino:= SemDestino + 1;

        Req.DescobrirCadeia(self.SemestreFeagri[sem - 1].MateriaSemestre[I].codigo);
        ReqFeagri:= Req.ConsultarCadeiaDePreRequisito;

        for J := low(ReqFeagri) to high(ReqFeagri) do
        begin

          for K := low(SemestreFeagri) to high(SemestreFeagri) do
           for L := 1 to 15 do
            if SemestreFeagri[K].MateriaSemestre[L].codigo = ReqFeagri[J] then
            begin
              SemOri:= K + 1;
              break;
            end;

         SemDestinoAux:= SemDestino + 1;

         if SemOri < SemDestinoAux then
         begin

          while (self.MudaSemestre(ReqFeagri[J],SemOri,SemDestinoAux,Hora,Req) = false) and (SemDestinoAux <= high(self.SemestreFeagri)) do
           SemDestinoAux:= SemDestinoAux + 1;

          SetLength(self.ListaDeAlteracoes, high(self.ListaDeAlteracoes) + 2);
          self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].Mat:= self.SemestreFeagri[sem].MateriaSemestre[I];
          self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].SemOrigem:= SemOri + 1;


         if SemDestino > high(self.SemestreFeagri) then
         begin
          self.ListaDeAlteracoes[high(self.ListaDeAlteracoes)].SemDestino:= SemDestino + 1;
          self.AdicionaMateriaNaLista(4,self.SemestreFeagri[SemOri - 1].MateriaSemestre[I],0);
         end;

         
        end;
       end;

       end
     else inc(I);
     end;
   end;

procedure TCatalogo.OrganizaLista;
var I,J,SemOri,SemDes:Integer;
    Mat:RMateria;
begin
for I := low(self.ListaDeAlteracoes) to high(self.ListaDeAlteracoes)-1 do
 for J := low(self.ListaDeAlteracoes)+1 to high(self.ListaDeAlteracoes) do
  if self.ListaDeAlteracoes[I].SemOrigem > self.ListaDeAlteracoes[J].SemOrigem then
  begin
    Mat:= self.ListaDeAlteracoes[I].Mat;
    SemOri:= self.ListaDeAlteracoes[I].SemOrigem;
    SemDes:= self.ListaDeAlteracoes[I].SemDestino;
    self.ListaDeAlteracoes[I]:= self.ListaDeAlteracoes[J];
    self.ListaDeAlteracoes[J].Mat:= Mat;
    self.ListaDeAlteracoes[J].SemOrigem:= SemOri;
    self.ListaDeAlteracoes[J].SemDestino:= SemDes; 
  end;
end;

// {$ENDREGION}

// {$REGION 'Métodos Públicos utilizados pelo módulo "Simulação Feagri"'}
    
function TCatalogo.ConsultaLegenda(cod: Integer):string;
var I,J:integer;
begin
 for I := low(self.SemestreFeagri) to high(self.SemestreFeagri) do
  for J := 1 to 15 do
  if self.SemestreFeagri[I].MateriaSemestre[J].codigo = cod then
  begin
   Result:= self.SemestreFeagri[I].MateriaSemestre[J].legenda;
   exit;
  end;

  for I := low(self.Eletivas) to high(self.Eletivas) do
  if (self.Eletivas[I].codigo = cod) then
   begin
    Result:= self.Eletivas[I].legenda;
    exit;
   end;

   for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
    if (self.AproveitamentoDeEstudos[I].codigo = cod) then
    begin
     Result:= self.AproveitamentoDeEstudos[I].legenda;
     exit;
    end;

   for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
    if (self.SemestreJubilado[I].codigo = cod) then
    begin
     Result:= self.SemestreJubilado[I].legenda;
     exit;
    end;

end;

function TCatalogo.MudaSemestre(mat: string; SemOri, SemDes: Integer; var Hora: THorarios; Req: TPreReq): boolean;
var mensagem:string;
    erro:boolean;
    I,Lista: integer;
    Disciplina: RMateria;
begin

 erro:= false;
 Lista:= 1;
 mensagem:= 'Não é possível cursar a matéria '+mat+ ' no '+ inttostr(SemDes)
 + ' semestre por causa do(s) motivo(s) abaixo:';

 for I := 1 to 15 do
 begin
  if self.SemestreFeagri[SemOri-1].MateriaSemestre[I].legenda = mat then
  begin
   Disciplina:= self.SemestreFeagri[SemOri-1].MateriaSemestre[I];
   break;
  end;
 end;

 if self.SemestreFeagri[SemOri-1].MateriaSemestre[15].legenda <> '' then
 begin
  mensagem:= mensagem + #13 + 'Limite de matérias no semestre';
  erro:= true;
 end; 


 if (self.SemestreFeagri[SemDes - 1].Travado) then
 begin
   mensagem:= mensagem + #13 + 'Semestre Travado';
   erro:= true;
 end;

 if Disciplina.sem <> 0 then
 begin
  if (self.SemestrePar(Disciplina.sem) <> self.SemestrePar(SemDes)) then
  begin
   mensagem:= mensagem + #13 + 'Semestre Errado';
   erro:= true;
  end;
 end
 else Lista:= 2;

 if (not self.TemCredito(SemDes,Disciplina.credito)) then
 begin
   mensagem:= mensagem + #13 + 'Créditos insuficientes para cursar a matéria';
   erro:= true;
 end;

 if (not self.VerificaCoeficiente(Disciplina,SemDes)) then
 begin
   mensagem:= mensagem + #13 + 'Porcentagem de Créditos para cursar a matéria não foi atingida';
   erro:= true;
 end;

  if (not Req.PodeCursar(self.SemestreFeagri, self.AproveitamentoDeEstudos, Disciplina.codigo, SemDes)) then
  begin
   mensagem:= mensagem + #13 + 'O pre requisito desta matéria impede de cursar';
   erro:= true;
  end;

  if (not Req.PodeCursarPreRequisito(self.SemestreFeagri, Disciplina.codigo, SemDes)) then
  begin
   mensagem:= mensagem + #13 + 'Não é possível cursar o pré-requisito depois da matéria consecutiva';
   erro:= true;
  end;

 {if (not Hora.VerificaHorarioDisponivel) then
 begin
   mensagem:= mensagem + #13 + 'Bate horario';
   erro:= true;
 end;}

 if (erro) then
 begin
  MessageDlg(mensagem, mtWarning, [mbOk], 0);
  Result:= False;
 end
 else
 begin
   self.RemoveMateriaDaLista(Lista,Disciplina,SemOri);
   self.AdicionaMateriaNaLista(Lista,Disciplina,SemDes);
   Result:= True;
 end;
 
end;

procedure TCatalogo.DispensaMateria(mat: string);
var I,J:integer;
begin
  SetLength(self.AproveitamentoDeEstudos,high(self.AproveitamentoDeEstudos)+2);

  for I := low(self.SemestreFeagri) to high(self.SemestreFeagri) do
   for J:= 1 to 15 do
   begin
    if (self.SemestreFeagri[I].MateriaSemestre[J].legenda = mat) then
  	begin
     self.AdicionaMateriaNaLista(2,self.SemestreFeagri[I].MateriaSemestre[J],-1);
     self.RemoveMateriaDaLista(1,self.SemestreFeagri[I].MateriaSemestre[J],I+1);
     exit;
  	end;
   end;

   for I := low(self.Eletivas) to high(self.Eletivas) do
   begin
    if (self.Eletivas[I].legenda = mat) then
  	begin
     self.AdicionaMateriaNaLista(2,self.SemestreFeagri[I].MateriaSemestre[J],-1);
     self.RemoveMateriaDaLista(2,self.Eletivas[I],0);
     exit;
  	end;
   end;

end;

procedure TCatalogo.ConsolidaSemestre(sem: integer; var Hora: THorarios; Req: TPreReq);
begin
 self.SemestreFeagri[sem - 1].Consolidado:= True;
 self.SemestreFeagri[sem - 1].Alteracao:= True;
 self.MovimentaGrade(sem,Hora,Req);
end;

procedure TCatalogo.TrancaSemestre(sem: integer; var Hora: THorarios; Req: TPreReq);
begin
 self.SemestreFeagri[sem - 1].Trancado:= True;
 self.SemestreFeagri[sem - 1].Alteracao:= True;
 self.AdicionaSemestre;
 self.MovimentaGrade(sem-1,Hora,Req);
end;

procedure TCatalogo.TravaSemestre(sem: integer);
begin
 self.SemestreFeagri[sem - 1].Travado:= not self.SemestreFeagri[sem - 1].Travado;
 self.SemestreFeagri[sem - 1].Alteracao:= True;
end;

function TCatalogo.ListaAlteracoes: Movimentacao;
begin
  OrganizaLista;
  Result:= self.ListaDeAlteracoes;
end;

procedure TCatalogo.TornaSimulada(legenda:string; SemOri,SemDes:integer);
var I:Integer;
begin
 for I := 1 to 15 do
 begin
  if self.SemestreFeagri[SemOri-1].MateriaSemestre[I].legenda = legenda then
  begin
    self.SemestreFeagri[SemOri-1].MateriaSemestre[I].turma:= 2;
    self.AdicionaMateriaNaLista(1,self.SemestreFeagri[SemOri-1].MateriaSemestre[I],SemDes);;
    self.RemoveMateriaDaLista(1,self.SemestreFeagri[SemOri-1].MateriaSemestre[I],SemOri);
  end;
 end;
end;

procedure TCatalogo.TornaNormal(legenda:string; SemOri,SemDes:integer);
begin

end;

procedure TCatalogo.SalvaCatalogo;
var I,J:integer;
begin
try
 for I := low(SemestreFeagri) to low(SemestreFeagri) do
 begin

  if (SemestreFeagri[I].Alteracao) then
  begin
    formprincipal.Feagri_Conector.Execute('Update Semestre set SemCons = '
    + booltostr(SemestreFeagri[I].Consolidado)+ ', SemTran = '
    + booltostr(SemestreFeagri[I].Trancado)+ ', SemTrav = '
    + booltostr(SemestreFeagri[I].Travado) + 'where AluRA = '+self.RA+ ' and SemCod = '+inttostr(I+1));
  end;

  for J := 1 to 15 do
  begin
   if SemestreFeagri[I].MateriaSemestre[J].legenda <> '' then
    if (SemestreFeagri[I].MateriaSemestre[J].alteracao) then
    begin
     formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(I+1) + ', HistCod = ' + inttostr(SemestreFeagri[I].MateriaSemestre[J].estado)
     + ' where CMCod = '+inttostr(SemestreFeagri[I].MateriaSemestre[J].codigo)
     + ' and AluRA = '+self.RA);
    end;
  end;

 end;

 for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
 begin
   if self.AproveitamentoDeEstudos[I].alteracao then
   begin
    formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(-1) + ', HistCod = ' + inttostr(self.AproveitamentoDeEstudos[I].estado)
     + ' where CMCod = '+inttostr(self.AproveitamentoDeEstudos[I].codigo)
     + ' and AluRA = '+self.RA);
   end;
 end;

 for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
 begin
  if self.SemestreJubilado[I].alteracao then
  begin
    formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(-2) + ', HistCod = ' + inttostr(self.SemestreJubilado[I].estado)
     + ' where CMCod = '+inttostr(self.SemestreJubilado[I].codigo)
     + ' and AluRA = '+ self.RA);
  end;
 end;


except
  Application.MessageBox('Erro ao gravar','Feagri',16);
end;

end;

procedure TCatalogo.ResetCatalogo;
var I,J:integer;
begin
try
 for I := low(SemestreFeagri) to low(SemestreFeagri) do
 begin
 
  if (I >= 0) and (I < 15) then
   formprincipal.Feagri_Conector.Execute('Update Semestre set SemCons = '+booltostr(false)+', SemTran = '
   + booltostr(false)+ ', SemTrav = '+ booltostr(false) + ' where AluRA = '+self.RA+ ' and SemCod = '+inttostr(I+1))
  else
    formprincipal.Feagri_Conector.Execute('Delete from Semestre where SemCod = '+inttostr(I));

  for J := 1 to 15 do
  begin
   if SemestreFeagri[I].MateriaSemestre[J].legenda <> '' then
    if SemestreFeagri[I].MateriaSemestre[J].turma <> 0 then
     formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(SemestreFeagri[I].MateriaSemestre[J].sem) + ', CMTCod = '
     + inttostr(SemestreFeagri[I].MateriaSemestre[J].turma) + ', HistCod = 3 where CMCod = '
     + inttostr(SemestreFeagri[I].MateriaSemestre[J].codigo)+ ' and AluRA = '+ self.RA)
    else
     formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(SemestreFeagri[I].MateriaSemestre[J].sem)+ ', HistCod = 3'
     + ', CMTCod = null where CMCod = '+ inttostr(SemestreFeagri[I].MateriaSemestre[J].codigo)
     + ' and AluRA = '+ self.RA)
   end;
   
 end;

 for I := low(self.AproveitamentoDeEstudos) to high(self.AproveitamentoDeEstudos) do
 begin
  formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(self.AproveitamentoDeEstudos[I].sem) + ', HistCod = 3'
     + ' where CMCod = '+inttostr(self.AproveitamentoDeEstudos[I].codigo)
     + ' and AluRA = '+self.RA);
 end;

 for I := low(self.SemestreJubilado) to high(self.SemestreJubilado) do
 begin
   formprincipal.Feagri_Conector.Execute('Update Cat_Mat_Tur_Hist set SemCur = '
     + inttostr(self.SemestreJubilado[I].sem) + ', HistCod = 3'
     + ' where CMCod = '+inttostr(self.SemestreJubilado[I].codigo)
     + ' and AluRA = '+self.RA);
 end;   

except
  Application.MessageBox('Erro ao resetar o sistema','Feagri',16);
end;

end;


//{$ENDREGION}

// {$REGION 'Classe TPreReq'}

constructor TPreReq.Create(aluRA: string; ano: Integer);
begin
  self.ano:= ano;
  self.aluRA:= aluRA;
  try
  self.CarregaPreRequisito;
  except
   Application.MessageBox('Erro ao carregar os pre requisitos das matérias','Feagri',16);
  end;
end;


procedure TPreReq.CarregaPreRequisito;
var rs: _recordset;
    cod, reqcod:integer;
begin
rs:= formprincipal.Feagri_Conector.Execute('select pre_req.cmcod, cmpcod from pre_req, cat_mat'
+ ' where cat_mat.cmcod = pre_req.cmcod and catcod ='+inttostr(self.ano));
cod:= 0;
reqcod:= 1;
while not rs.EOF do
begin
 if cod <> rs.Fields[0].Value then
 begin
   SetLength(PreReq,high(PreReq)+2);
   PreReq[high(PreReq)].codigo:= strtoint(rs.Fields[0].Value);
   cod:= strtoint(rs.Fields[0].Value);
   reqcod:=1;
 end;
 PreReq[high(PreReq)].pre_req[reqcod]:= strtoint(rs.Fields[1].Value);
 inc(reqcod);
 rs.MoveNext;
end;
end;

function TPreReq.TemPreRequisito(cod: integer):boolean;
var I:integer;
begin
Result:= false;
for I := low(self.PreReq) to high(self.PreReq) do
begin
  if PreReq[I].codigo = cod then
  begin
    Result:= true;
    exit;
  end;
end;
end;

function TPreReq.PodeCursar(Feagri :SemestreDoAluno; Dispensa: array of RMateria; mat: integer; sem: Integer):boolean;
var I,J,K,L:integer;
    PreReqOk: array of boolean;
begin
Result:= true;
 if not self.TemPreRequisito(mat) then exit
 else
 begin
  for I := low(self.PreReq) to high(self.PreReq) do
  begin
   if PreReq[I].codigo = mat then
   begin

    for J := low(PreReq[I].pre_req) to low(PreReq[I].pre_req) do
    begin
     SetLength(PreReqOk,high(PreReq[I].pre_req)+1);
     PreReqOk[J]:= false;

     for K := low(Feagri) to sem - 2 do
      for L := 1 to 15 do
       if Feagri[K].MateriaSemestre[L].codigo = mat then PreReqOk[J]:= True;

     for K := low(Dispensa) to high(Dispensa) do
       if Dispensa[K].codigo = mat then PreReqOk[J]:= True;

     if not PreReqOk[J] then
     begin
      Result:= False;
      exit;
     end;

    end;
   end;
  end;
 end;
end;

function TPreReq.PodeCursarPreRequisito(Feagri :SemestreDoAluno; mat: integer; sem: Integer):boolean;
var I,J,K:Integer;
begin
 Result:= True;
 self.DescobrirCadeia(mat);
  for I := low(self.PreRequisitos) to high(self.PreRequisitos) do
 begin
   for J := low(Feagri) to sem - 1 do
  begin
   for K := 1 to 15 do
    if Feagri[J].MateriaSemestre[K].codigo = self.PreRequisitos[I] then
    begin
     Result:= false;
     self.PreRequisitos:= nil;
     exit;
    end;
   end;
  end;
  self.PreRequisitos:= nil;
end;

procedure TPreReq.DescobrirCadeia(cod: Integer);
var J,K:Integer;
begin
 for J := low(self.PreReq) to high(self.PreReq) do
  for K := 1 to 5 do
  begin
   if self.PreReq[J].pre_req[k] = cod then
   begin
     SetLength(PreRequisitos,high(PreRequisitos)+2);
     PreRequisitos[high(PreRequisitos)]:= self.PreReq[J].codigo;
     self.DescobrirCadeia(self.PreReq[J].codigo);
   end;
  end;
end;

function TPreReq.ConsultarCadeiaDePreRequisito: CadeiaDePreRequisitos;
begin
  Result:= self.PreRequisitos;
  self.PreRequisitos:= nil;
end;

//{$ENDREGION}

end.
